# This could change in the future, but to minimize changes to go-fuzz, we currently invoke go-fuzz-build and go-fuzz via 'exec'.
# For consistency, we also invoke cmd/go via 'exec' as well.

# Enter a module that depends on a v2+ module.
cd foo 

# Sanity check the module seems well formed.
exec go list -m all
stdout '^example.com/foo$'
stdout '^example.com/bar/v2 v2.0.0 => ../bar$'
exec go build

# Ask go-fuzz-build to build, which should find the fuzz target in foo.
# foo is a module itself, as well as foo depends on a v2 module.
# v2 modules are particularly problematic if not handled properly.
exec go-fuzz-build -func=FuzzDependOnV2Mod

# Sanity check github.com/dvyukov/go-fuzz was added to our go.mod and is now visible via 'go list -m all'.
# This is not necessarily a requirement for all time, but this is the way the current modules approach for go-fuzz works.
# This is important to make sure the go-fuzz-dep source code is findable by go-fuzz-build (when it invokes 'go list').
exec go list -m all
stdout '^example.com/foo$'
stdout '^example.com/bar/v2 v2.0.0 => ../bar$'
stdout '^github.com/dvyukov/go-fuzz v0.0.0-[^ ]+$'

# Also output directories for go-fuzz-defs and go-fuzz-deps in case we need to debug this at some point in the future.
exec go list -f {{.Dir}} github.com/dvyukov/go-fuzz/go-fuzz-defs
exec go list -f {{.Dir}} github.com/dvyukov/go-fuzz/go-fuzz-deps

# Define two modules.
# example.com/foo has a fuzz function, and depends on example.com/bar/v2.

-- foo/go.mod --
module example.com/foo

require example.com/bar/v2 v2.0.0

replace example.com/bar/v2 => ../bar

-- foo/fuzz.go --
package foo

import "example.com/bar/v2"

func FuzzDependOnV2Mod(data []byte) int {
    bar.Bar()
    return 0
}

-- bar/go.mod --
module example.com/bar/v2

-- bar/bar.go --
package bar

func Bar() string {
    return "hello from bar"
}
